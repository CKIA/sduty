redis 数据结构
	1、String
	    可以是字符串，整数或者浮点数，对整个字符串或者字符串中的一部分执行操作，对整个整数或者浮点执行自增(increment)或者自减(decrement)操作。
	字符串命令：
	    ①get、获取存储在指定键中的值
	    ②set、设置存储在指定键中的值
	    ③del、删除存储在指定键中的值（这个命令可以用于所有的类型）

	2、list
	    一个链表，链表上的每个节点都包含了一个字符串，虫链表的两端推入或者弹出元素，根据偏移量对链表进行修剪(trim)，读取单个或者多个元素，根据值查找或者移除元素。
	列表命令：
	    ①rpush、将给定值推入列表的右端
	    ②lrange、获取列表在指定范围上的所有值
	    ③lindex、获取列表在指定范围上的单个元素
	    ④lpop、从列表的左端弹出一个值，并返回被弹出的值

	3、set
	    包含字符串的无序收集器(unordered collection)、并且被包含的每个字符串都是独一无二的。添加，获取，移除单个元素，检查一个元素是否存在于集合中，计算交集，并集，差集，从集合里面随机获取元素。
	集合命令：
	    ①sadd、将给定元素添加到集合
	    ②smembers、返回集合包含的所有元素
	    ③sismember、检查指定元素是否存在于集合中
	    ④srem、检查指定元素是否存在于集合中，那么移除这个元素


	4、hash
		包含键值对无序散列表，添加，获取，移除当键值对，获取所有键值对。
	散列命令：
	    ①hset、在散列里面关联起指定的键值对
	    ②hget、获取指定散列键的值
	    ③hgetall、获取散列包含的所有键值对
	    ④hdel、如果给定键存在于散列里面，那么移除这个键

	5、zset
	    字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定。添加，获取，删除单个元素，根据分值范围(range)或者成员来获取元素。
	有序集合命令：
		①zadd、将一个带有给定分值的成员添加到有序集合里面
		②zrange、根据元素在有序排列中所处的位置，从有序集合里面获取多个元素
		③zrangebyscore、获取有序集合在给定分值范围内的所有元素
		④zrem、如果指定成员存在于有序集合中，那么移除这个成员

	持久化之RDB和AOF
		REB 默认开启的
			触发RDB快照
				1 在指定的时间间隔内，执行指定次数的写操作
				2 执行save（阻塞， 只管保存快照，其他的等待） 或者是bgsave （异步）命令
				3 执行flushall 命令，清空数据库所有数据，意义不大。
				4 执行shutdown 命令，保证服务器正常关闭且不丢失任何数据，意义...也不大。
			优点：
				1 适合大规模的数据恢复。
				2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。
			缺点：
				1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。
				2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。
				所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。

		AOF ：Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。
			AOF的重写机制
				前面也说到了，AOF的工作原理是将写操作追加到文件中，文件的冗余内容会越来越多。所以聪明的 Redis 新增了重写机制。当AOF文件的大小超过所设定的阈值时，Redis就会对AOF文件的内容压缩。
				重写的原理：Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？ o(ﾟДﾟ)っ傻啊！）。最后替换旧的aof文件。
				触发机制：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。这里的“一倍”和“64M” 可以通过配置文件修改。
			优点：数据的完整性和一致性更高
			缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。

	redis过期策略
		# maxmemory-policy volatile-lru
		该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)
		1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
		2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。
		3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。
		4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐
		5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐
		6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐
		ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。


	2、使用redis有什么缺点
		分析:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。
		回答:主要是四个问题
		(一)缓存和数据库双写一致性问题
		(二)缓存雪崩问题
		(三)缓存击穿问题
		(四)缓存的并发竞争问题

	缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。
		解决方案:
		(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
		(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
		(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。

	缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
		解决方案:
		(一)给缓存的失效时间，加上一个随机值，避免集体失效。
		(二)使用互斥锁，但是该方案吞吐量明显下降了。
		(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点
		I 从缓存A读数据库，有则直接返回
		II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。
		III 更新线程同时更新缓存A和缓存B。
	如何解决redis的并发竞争key问题
		分析:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。

		回答:如下所示
		(1)如果对这个key操作，不要求顺序
		这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。
		(2)如果对这个key操作，要求顺序
		假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.
		期望按照key1的value值按照 valueA-->valueB-->valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下

		系统A key 1 {valueA  3:00}
		系统B key 1 {valueB  3:05}
		系统C key 1 {valueC  3:10}
		那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。

		其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。